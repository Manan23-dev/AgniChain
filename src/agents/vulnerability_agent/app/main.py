"""Vulnerability Agent: OSV/NVD correlation service."""
import hashlib
import hmac
import json
import logging
import os
from datetime import datetime
from typing import Optional

from fastapi import FastAPI, HTTPException, Header, Request
from fastapi.responses import JSONResponse
from google.cloud import firestore

from models import CorrelationRecord
from osv import correlate_components

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "module": "%(name)s"}',
)
logger = logging.getLogger(__name__)

app = FastAPI(title="Vulnerability Agent")

# Environment variables
GCP_PROJECT_ID = os.getenv("GCP_PROJECT_ID")
FIRESTORE_COLLECTION = os.getenv("FIRESTORE_COLLECTION", "aegis_findings")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET")
OSV_API_URL = os.getenv("OSV_API_URL", "https://api.osv.dev/v1/query")

# Initialize Firestore
db = None
if GCP_PROJECT_ID:
    db = firestore.Client(project=GCP_PROJECT_ID)


def verify_github_signature(payload_body: bytes, signature: str) -> bool:
    """
    Verify GitHub webhook signature using HMAC.
    
    Args:
        payload_body: Raw request body
        signature: X-Hub-Signature-256 header value
        
    Returns:
        True if signature is valid
    """
    if not WEBHOOK_SECRET:
        logger.warning("WEBHOOK_SECRET not set, skipping signature verification")
        return True  # Allow if secret not configured
    
    if not signature:
        return False
    
    # GitHub sends "sha256=<hash>"
    if not signature.startswith("sha256="):
        return False
    
    expected_signature = signature[7:]  # Remove "sha256=" prefix
    
    # Compute HMAC
    computed_hash = hmac.new(
        WEBHOOK_SECRET.encode("utf-8"),
        payload_body,
        hashlib.sha256,
    ).hexdigest()
    
    # Constant-time comparison
    return hmac.compare_digest(computed_hash, expected_signature)


@app.get("/healthz")
async def healthz():
    """Health check endpoint."""
    if not GCP_PROJECT_ID:
        return JSONResponse(
            status_code=503,
            content={"status": "unhealthy", "reason": "GCP_PROJECT_ID not configured"},
        )
    return {"status": "healthy"}


@app.post("/webhook/github")
async def webhook_github(
    request: Request,
    x_hub_signature_256: Optional[str] = Header(None, alias="X-Hub-Signature-256"),
):
    """
    GitHub webhook endpoint for PR events.
    
    Validates signature and triggers correlation for new PRs.
    """
    body = await request.body()
    
    # Verify signature
    if not verify_github_signature(body, x_hub_signature_256):
        logger.warning("Invalid webhook signature")
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    # Parse payload
    try:
        payload = await request.json()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON: {e}")
    
    # Validate PR event
    event_type = request.headers.get("X-GitHub-Event")
    if event_type != "pull_request":
        return {"status": "ignored", "event_type": event_type}
    
    action = payload.get("action")
    if action not in ["opened", "synchronize"]:
        return {"status": "ignored", "action": action}
    
    pr = payload.get("pull_request", {})
    pr_number = str(pr.get("number"))
    commit_sha = pr.get("head", {}).get("sha")
    
    if not all([pr_number, commit_sha]):
        raise HTTPException(
            status_code=400, detail="Missing pr_number or commit_sha in payload"
        )
    
    logger.info(f"Processing PR webhook: PR #{pr_number}, commit {commit_sha}")
    
    # Find corresponding scan document
    if not db:
        raise HTTPException(status_code=503, detail="Firestore not initialized")
    
    scan_doc_id = f"scan_{pr_number}_{commit_sha}"
    scan_doc = db.collection(FIRESTORE_COLLECTION).document(scan_doc_id).get()
    
    if not scan_doc.exists:
        logger.warning(f"Scan document not found: {scan_doc_id}")
        return {
            "status": "pending",
            "message": "Scan not yet complete, correlation will be triggered later",
        }
    
    scan_data = scan_doc.to_dict()
    sbom_components = scan_data.get("sbom_components", [])
    
    if not sbom_components:
        logger.info(f"No SBOM components found for {scan_doc_id}")
        return {"status": "skipped", "reason": "No SBOM components"}
    
    # Trigger correlation (async, don't wait)
    import asyncio
    
    asyncio.create_task(
        perform_correlation(pr_number, commit_sha, sbom_components, scan_doc_id)
    )
    
    return {"status": "accepted", "pr_number": pr_number, "commit_sha": commit_sha}


async def perform_correlation(
    pr_number: str,
    commit_sha: str,
    sbom_components: list,
    scan_doc_id: str,
):
    """Perform correlation and persist result."""
    try:
        enriched = await correlate_components(sbom_components)
        
        # Persist correlation record
        correlation_doc_id = f"correlation_{pr_number}_{commit_sha}"
        correlation_data = {
            "pr_number": pr_number,
            "commit_sha": commit_sha,
            "components": [comp.dict() for comp in enriched],
            "created_at": firestore.SERVER_TIMESTAMP,
            "scan_doc_id": scan_doc_id,
            "type": "correlation",
        }
        
        db.collection(FIRESTORE_COLLECTION).document(correlation_doc_id).set(
            correlation_data
        )
        
        logger.info(f"Correlation complete: {correlation_doc_id}")
    except Exception as e:
        logger.error(f"Correlation failed: {e}", exc_info=True)


@app.post("/correlate")
async def correlate_endpoint(request: Request):
    """
    Manual correlation endpoint.
    
    Body: {
        "pr_number": "...",
        "commit_sha": "...",
        "components": [...]
    }
    """
    try:
        payload = await request.json()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON: {e}")
    
    pr_number = payload.get("pr_number")
    commit_sha = payload.get("commit_sha")
    components = payload.get("components", [])
    
    if not all([pr_number, commit_sha]):
        raise HTTPException(
            status_code=400, detail="Missing pr_number or commit_sha"
        )
    
    if not components:
        raise HTTPException(status_code=400, detail="No components provided")
    
    try:
        enriched = await correlate_components(components)
        
        # Persist if requested
        persist = payload.get("persist", True)
        if persist and db:
            correlation_doc_id = f"correlation_{pr_number}_{commit_sha}"
            correlation_data = {
                "pr_number": pr_number,
                "commit_sha": commit_sha,
                "components": [comp.dict() for comp in enriched],
                "created_at": firestore.SERVER_TIMESTAMP,
                "type": "correlation",
            }
            
            db.collection(FIRESTORE_COLLECTION).document(correlation_doc_id).set(
                correlation_data
            )
        
        return {
            "pr_number": pr_number,
            "commit_sha": commit_sha,
            "components": [comp.dict() for comp in enriched],
        }
    except Exception as e:
        logger.error(f"Correlation failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    import uvicorn
    
    port = int(os.getenv("PORT", 8080))
    uvicorn.run(app, host="0.0.0.0", port=port)
