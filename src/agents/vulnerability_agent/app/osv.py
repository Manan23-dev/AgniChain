"""OSV API client with exponential backoff."""
import asyncio
import logging
import os
from typing import List, Optional

import httpx
from pydantic import BaseModel

from models import EnrichedComponent, OSVVulnerability

logger = logging.getLogger(__name__)

OSV_API_URL = os.getenv("OSV_API_URL", "https://api.osv.dev/v1/query")
MAX_RETRIES = 3
INITIAL_BACKOFF = 1.0  # seconds


class OSVQuery(BaseModel):
    """OSV query model."""
    package: dict
    version: Optional[str] = None


async def query_osv_with_backoff(
    component_name: str,
    ecosystem: str,
    version: str,
    retry_count: int = 0,
) -> List[OSVVulnerability]:
    """
    Query OSV API with exponential backoff.
    
    Args:
        component_name: Package name
        ecosystem: Ecosystem (npm, pypi, etc.)
        version: Package version
        retry_count: Current retry attempt
        
    Returns:
        List of vulnerabilities
    """
    query = {
        "package": {
            "name": component_name,
            "ecosystem": ecosystem,
        },
        "version": version,
    }
    
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(OSV_API_URL, json=query)
            response.raise_for_status()
            data = response.json()
            
            vulnerabilities = []
            if "vulns" in data:
                for vuln in data["vulns"]:
                    # Extract severity if available
                    severity = None
                    if "database_specific" in vuln:
                        db_specific = vuln["database_specific"]
                        if "severity" in db_specific:
                            sev_data = db_specific["severity"]
                            if isinstance(sev_data, list) and len(sev_data) > 0:
                                severity = sev_data[0].get("type", "").upper()
                    
                    vulnerabilities.append(
                        OSVVulnerability(
                            id=vuln.get("id", ""),
                            summary=vuln.get("summary"),
                            severity=severity,
                            references=vuln.get("references", []),
                            published=vuln.get("published"),
                            modified=vuln.get("modified"),
                        )
                    )
            
            return vulnerabilities
            
    except httpx.HTTPStatusError as e:
        if e.response.status_code == 429:  # Rate limit
            if retry_count < MAX_RETRIES:
                backoff_time = INITIAL_BACKOFF * (2 ** retry_count)
                logger.warning(
                    f"Rate limited, backing off for {backoff_time}s (attempt {retry_count + 1})"
                )
                await asyncio.sleep(backoff_time)
                return await query_osv_with_backoff(
                    component_name, ecosystem, version, retry_count + 1
                )
            else:
                logger.error(f"Max retries reached for {component_name}")
                return []
        else:
            logger.error(f"OSV API error for {component_name}: {e}")
            return []
    except Exception as e:
        logger.error(f"Unexpected error querying OSV for {component_name}: {e}")
        return []


async def correlate_components(
    components: List[dict],
) -> List[EnrichedComponent]:
    """
    Correlate SBOM components with OSV.
    
    Args:
        components: List of component dicts from SBOM
        
    Returns:
        List of enriched components with vulnerabilities
    """
    enriched = []
    
    # Deduplicate by ecosystem+name+version
    seen = set()
    unique_components = []
    for comp in components:
        key = (comp.get("ecosystem"), comp.get("name"), comp.get("version"))
        if key not in seen:
            seen.add(key)
            unique_components.append(comp)
    
    # Query OSV for each unique component
    for comp in unique_components:
        name = comp.get("name")
        version = comp.get("version")
        ecosystem = comp.get("ecosystem")
        
        if not all([name, version, ecosystem]):
            continue
        
        # Map ecosystem names to OSV format
        osv_ecosystem = ecosystem.lower()
        if osv_ecosystem == "npm":
            osv_ecosystem = "npm"
        elif osv_ecosystem == "pypi":
            osv_ecosystem = "PyPI"
        else:
            # Try as-is
            pass
        
        vulnerabilities = await query_osv_with_backoff(name, osv_ecosystem, version)
        
        enriched.append(
            EnrichedComponent(
                name=name,
                version=version,
                ecosystem=ecosystem,
                purl=comp.get("purl"),
                vulnerabilities=vulnerabilities,
            )
        )
        
        # Small delay to avoid rate limits
        await asyncio.sleep(0.1)
    
    return enriched

